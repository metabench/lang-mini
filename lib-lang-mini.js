const lang = require('./lang-mini');

const {each, tof} = lang;


// and lang types...
//  Will use a Type class.
//   Number_Type etc. String_Type perhaps.
//     and then restrictions. JSON_Type is a String_Type.



// Could have first implementation of types here even....
//   Maybe don't use classes for them?
//     Or do because they are so integrated into the language now.

// Representation_Type
//   eg represents a color (in specific way?) How it represents it...?
//     ?? represents a 24bit rgb color ??
//       why not? should be possible.


// Some / all of oext would be nice within lang-mini...?

// oext seems to work with types though, or would benefit from types.
//   No, oext does not have much for types, moving field and prop from oext here, need to get the data types working with Data_Object
//   and Data_Value. 





// Maybe move to lang-tools?
//   fp() may benefit from integration with this.



// What the type represents.
// What it signifies?

// But then how it's represented?


// Not really about storing the data in memory or transmitting it.
//   But saying it's 24 bit color is kind of about its representation.
//   Still that's what it's called.

// Type_Signifier seems better. Now it's called that.

// Wider signification than just JS.


// Type_Signifier_Component ????

// Type_Signifier perhaps. Signifier_Type???

class Type_Signifier {
    // Name
    constructor(spec = {}) {

        const name = spec.name;

        Object.defineProperty(this, 'name', {
            get() {
                return name;
            }
        });

        const parent = spec.parent;

        Object.defineProperty(this, 'parent', {
            get() {
                return parent;
            }
        });

        const map_reserved_property_names = {
            name: true,
            parent: true
        }

        const _ = {};

        each(spec, (value, name) => {
            if (map_reserved_property_names[name]) {

            } else {
                _[name] = value;
            }
        });



        // And other fields too....


    }
    extend(o_extension) {

        const o = {
            parent: this
        }
        Object.assign(o, o_extension);
        const res = new Type_Signifier(o_extension);
        return res;


    }
    //  Other options?
    //  Disambiguiation? Descriptive text?
    //    Or is naming them the main thing there?

    // Color representation
    //   And that is simple, does not go into internal representation.

}




// A representation for what is signified.
//   This way if the programmer gets stuck about 'the' representation to make, they can make a decent representation, make it default,
//     and move on for the moment.


// Can be multiple allowed representations for a type.
//   Binary data, JSON
//   Compressed, uncompressed, maybe encrypted too.


// Probably don't need subclasses for string or binary representations.
//  Make this able to deal with both.
//  String (kind of) is binary but likely uses UTF-8.

class Type_Representation {
    // Name
    //  Other options?
    //  Disambiguiation? Descriptive text?
    //    Or is naming them the main thing there?

    // Color representation
    //   And that is simple, does not go into internal representation.

    // This should be able to represent types and lang features not available to JS.
    //   Names may be optional? May be autogenerated and quite long?



    constructor(spec = {}) {

        // May be used on a lower level where the most suitable representation is selected.

        // Generally:
        //  string incl json
        //  binary

        // bridge the gap between numeric and binary.
        //   make this ta-friendly and aware.

        // represent components within a typed array? closely packed data structure?
        

        const name = spec.name;
        Object.defineProperty(this, 'name', {
            get() {
                return name;
            }
        });

        const parent = spec.parent;
        Object.defineProperty(this, 'parent', {
            get() {
                return parent;
            }
        });

        // Then the other fields?
        //  Could have named fields.
        //  Could have ordered fields?

        const _ = {};

        const map_reserved_property_names = {
            'name': true
        };

        //  Even the number of bits being in here...?

        each(spec, (value, name) => {
            if (map_reserved_property_names[name]) {

            } else {
                _[name] = value;

                // Could define the property here.
                //  Read only (for the moment)

                Object.defineProperty(this, name, {
                    get() {
                        return _[name];
                    },
                    enumerable: true
                });


            }
        });
        // Then a proxy to get other properties?
    }
    extend(o_extension) {

        const o = {
            parent: this
        }
        Object.assign(o, o_extension);
        const res = new Type_Representation(o_extension);
        return res;


    }

}

// Will spell out some things in a quite verbose vanilla-js way here.
//   Some higher level code will use types and other lang functionality to be less verbose and closer to English / the direct concepts.

// Joins together 1 signifier and multiple representations.
//   Name of item will be the signifier's name.

class Signifier_Representations_Type {
    constructor(spec = {}) {
        // 2 params in constructor? (signifier, arr_reps)???
        //  could check for that.

        if (spec.signifier && spec.representations) {

            let signifier, arr_representations;

            //if (spec.signifier) {
            if (spec.signifier instanceof Type_Signifier) {
                signifier = spec.signifier;
            } else {
                throw 'expected spec.signifier to be a Type_Signifier instance';
            }
            //}

            if (tof(spec.representations) === 'array') {
                let pass = true;
                each(spec.representations, (representation, idx, stop) => {
                    if (!(representation instanceof Type_Representation)) {
                        pass = false;
                        stop();
                    }
                })
                if (pass) {
                    arr_representations = spec.representations;
                } else {
                    throw 'Expected spec.representations to be an array of Type_Representation instances.';
                }
            }





        } else {
            throw 'Expected spec.signifier and spec.representations'
        }

        



    }
}






// And could be subclasses of signification types...???

// ui8 type signification?
//   OK to signify that type, could indeed be represented with different actual values.
//    such as as a string of decimal or hex digits.


// Will have some basic / core types within lang-mini.
//   Will not have a large amount of code.


// Thematic types perhaps....
//   seems like there could be overlap as well, eg image and document, text and document
//   color, date/time, image, video, text, document, font, number, integer, floating point, string
//     Type signifier could have theme property instead of or as well as name?
//       Then representation of one thing as another. Represent a color as a number.

// One advantage of putting in its own module is possible smaller file size.
//   Though could possibly use lang-mini functionality as a platform for signifier and representer types.
//   Type_Representer perhaps, not Type_Representation???
//     Representation is probably the more accurate / better reading word.




const st_color = new Type_Signifier({'name': 'color'});

// Signify an image. Signify a JPEG image. Etc.

// then make a new one that extends st_color
//   as in, a subtype.
const st_24bit_color = st_color.extend({'bits': 24});
// Other types of 3 component color?

//const st_24bit_rgb_color = st_24bit_color.extend({'components': ['red', 'green', 'blue']});
const st_24bit_rgb_color = st_24bit_color.extend({'components': ['red byte', 'green byte', 'blue byte']});
//  or it already knows that these are bytes, when its 3 components in 24 bits.

// st_24bit_rgb_color is only a signifier of 24 bit rgb color.
//  Then there can be an implementation of it.
//  Or a type (or class etc) could indicate it can handle it.

// Type representation index could help.
//   Query by name could return multiple items....
//     Could have a property for the default representation with the name being searched for.






// And have info about the properties by which it is represented?

const tr_string = new Type_Representation({'name': 'string'});
const tr_binary = new Type_Representation({'name': 'binary'}); // And could include number....
// Numbers maybe extend binary.

// And tr_ui8 even perhaps....




// represent it as a binary sequence.
//   Then could use more application specific tools like a Buffer or Typed Array.

// Or extend the string type representation?

// = tr_binary.extend();
// trep maybe. and tsig or tsign.

// Will make / finish some lower level components that interact with some specifically typed data.
//   May well be worth doing more under 'grammar', getting type signifiers and type representations into the system.
//     So far, types have been type representations. Now, they can be a signifier along with multiple representations.
// A 'tags' type system of properties could help. Make it easy to specify / set up types.

// Representation = Implementation (kind of)
//   Or an interface.

// Could use a Representation as an interface, in some cases.
//   Inner representations as well
//   Eg single color channel has a representation
//     Would have a color name.
//       Could even have a wavelength measurement for the color.

// color channel 8 bit
//   could use some language interpretation even. Some language processing could have the system 'understand' simple phrases describing
//   type representations.

// Actually using struct syntax for C++ or rust would be really good.
//   Rust structs don't require fixed length strings in definition.

// A struct being a Type_Representation, or Representational_Type.
//   Dates can and do operate on different calendars.
//     Same thing being signified, but with a different representation.
// Diffent ways of representing strings and text. Now emojis too, they are part of unicode, and they keep getting updated.

// Text characters are images that represent a letter or something else.
//   They are symbols.


















const rt_bin_24bit_rgb_color = new Type_Representation({
    // A binary type representation.
    'signifier': st_24bit_rgb_color,
    'bytes': [
        [0, 'red', 'ui8'],
        [1, 'green', 'ui8'],
        [2, 'blue', 'ui8']
    ]
});

// Maybe do some work on a concise format for defining these types.
// Maybe worth using or allowing the exact same syntax as C++ and/or rust for these stucts.
//  Possibly some kind of syntax import. An example of how the same type of information can have different representations.




// And an editor control could use a representation in terms of how it represents the data being edited to the user.

// Binary type representation
const rt_hex_24bit_rgb_color = new Type_Representation({
    // Likely some kind of string template.
    //  Or a function?
    //  Best to keep this function free here.
    //  Or maybe make a few quite standard ones.
    'signifier': st_24bit_rgb_color,

    // Or could just have the sequence / template literal even.

    'bytes': [
        [0, '#', 'char'],
        [1, 'hex(red)', 'string(2)'],
        [3, 'hex(green)', 'string(2)'],
        [5, 'hex(blue)', 'string(2)']
    ]
});

// Year could be negative.
const st_date = new Type_Signifier({'name': 'date', 'components': ['day uint', 'month uint', 'year int']});
// And datetime signification.

// Approximate date ie date +- x years.


// Just the date.



//  or don't have the component types here?

// String representation type.
//  String_Type_Representation

// Lots of different ways to represent a type.

// Or say that they are numeric strings as well....

// But a string char possibly takes more than 1 byte! Maybe not as defined here.
//  String of int?
//  Go into more details about how dates are represented?

// Could consider JPEG to be a representation of Image.
//   May want / need to think in terms of segments or blocks...
//    segment_name = 'block' even. So it at least knows the right technical term.
//   JPEG can have different versions, or subrepresentations.
//     Type representations can have a supertype. That can be used with JPEG and then their versions are subtypes.
//       A bit like the super-JPEG is a type representation of its own - except its got the details of the syntax.
//     Want to make the overall system flexible in terms of what it represesnts, a fairly simple base structure.


// Maybe make sections that define the representations just after the signifiers.
//   Could have a fair few basic things defined.

// Type Signifiers and Type Representations
//   Think it could become an interesting book / programming topic.
//   Could have implementations in a few languages too. Maybe suggestions for future languages and versions of them.

// Make it its own module even?
//   Could work better at a lower level.

// srtypes module perhaps, or just srtype.
// Coding with the distinction between signified and represented types could be really useful.
//   Be able to handle serialization and deserialization (or format changes in some cases) 'for free', that is once the definitions
//     have been made, the system will be able to convert between them (maybe requires some conversion functions to be written)
//   System will have decent default type conversions.

// Probably worth having set of 'standard' type definitions.
//   System needs to be flexible so that they can be amended.












const rt_string_date_uk_ddmmyy = new Type_Representation({
    'signifier': st_date,
    'bytes': [
        [0, '#', 'char'],
        [1, 'day', 'string(2)'],
        [3, '/', 'char'],
        [4, 'month', 'string(2)'],
        [6, '/', 'char'],
        [7, 'year', 'string(2)']
    ]
});

// Extra rules or restrictions? Defaults eg year 38 is 2038 etc...


// A types registry could help.
//  Registry of signified types
//  Registry of type representations.
//   Meaning 1 'type' in this system can be represented in multiple different ways.

// Then the infrastructure within control declaration...
//   Though likely will use the .model and .view mixins for this.
//   Views (or controls?) will be made so that the model is a specific representation of a signified type.
//     Or one a a few supported representations.
//     Eg a color palette working for monochrome (8bit color depth).
//       Or a color palette could allow selection of multiple colors.

// Color_Chooser perhaps being simpler?
//   Color_Palette seems like it should be able to deal with a bunch of different ways in which the data could be represented
//     either in the app as the user interacts with it, in app memory, in transmission, in storage.










// There could be quite a lot of these type representations.



// Can have plenty of ways of representing a date. Fewer ways of signifying one.


// To signify something is in some ways less than to represent it.
//   Signification is only about saying that it is there.

// Maybe have a nice UI app to set up the signifier / representer links.





// A moderate amount of data type representation info would help get JSGUI controls working nicely on the specific types
//   of data they are supposed to interact with.

// Ways of getting the data in and out of typed arrays
//   Typed array (or buffer?) access for these data types?

// Could make some nice GUI components (controls) for selecing / editing dates and colors.
//   Can do it in a way that avoids code repetition.
//   Make it so that the controls are able to represent the type on the screen.





 
// These types seem most useful for the types that the user interacts with and putting the type knowledge into the GUI.

// Type registry makes sense too.
//  jsgui.types perhaps / lang.types
//   An index of types? Collection of them?

// Also registry of controls that are set up for dealing with specific types?
//   Being able to identify and use variety of representations.

// May integrate this into image format work - or make this good so that image format work can use this as a platform.









// and then day, month, year components




// day, month year



// or 'hexdigit(2)' maybe.

// And the Control could conveniently show and allow editing of values using different representations.
//   Such as a hex representation, or hex representations for comonents.

// A Control could be aware of, and use both representations of a Data_Type.
//   Color Palette seems like the right place to use that more advanced and general purpose functionality.
//     Will work well for some imaging tools as well too.


// More functional composition of controls could be cool....
//   But let's make / improve the color palette.
//     Moving the data outside it could work too.
//     Consts directory. Or basis. Basics.



// Have a class / instance of one that tracks ie is a DB for the type representations and significations.











// Then put that within an array? 32 bit number used as 24 bit?


// Though it may be most/least significant in some cases.




// Then create a representation of 24 bit rgb color where it's the 3 components as bytes.
//   Could be deduced from what we have already. May be easy enough to get from the Type_Signifier to this.
//     However, will then have representations of the individual components too....
//     Perhaps represent the whole thing as a string. eg #RRGGBB color for HTML. Or as items in an array.
//       Even representing them as items within a typed array.


// Allowing multiple representations of the same things.
//   Representation sets - so we know which representations as (almost? totally?) interchangable.
//   Can choose different default representations depending on performance.

// Or implementation sets? Prefer representation here to describe how the types are represented rather than other connotations
//   such as code for operators.

//console.log('st_color', st_color);

lang.Type_Signifier = Type_Signifier;
lang.Type_Representation = Type_Representation;




// Let's make something a little simpler and focused on representing the types of data in Data_Model classes.
//   Control is such a class through inheritance, it extends Data_Object.

// nfdt new functional data type function....?







// The representation type is a way to represent something
//   What is being represented? That is all within a signifier type.

// Or Implementation_Type? As in that is concrete in terms of how it is represented.
// Representation_Implementation_Type???







module.exports = lang;